package gen

import (
	cr "crypto/rand"
	"encoding/binary"
	"fmt"
	"hash/fnv"
	mr "math/rand"
	"sync"
)

var mathRandSrc *mr.Rand

func init() {
	seed := CryptoRandInt64()
	mathRandSrc = mr.New(mr.NewSource(seed))
}

var fileNameHash string

func SetFilename(fn string) {
	h := fnv.New64a()
	h.Write([]byte(fn))
	fileNameHash = fmt.Sprintf("%x", h.Sum64())
}

// generate a unconflicting symbol name
func gensym() string {
	return "zgensym_" + fileNameHash + fmt.Sprintf("_%d", genSerial())
}

// generate a random identifier name
func randIdentOldVersion() string {
	bts := make([]byte, idxLen)
	for i := range bts {
		bts[i] = idxChars[cryptoRandIntn(len(idxChars))]
	}

	// Use a `z` prefix so the randomly generated bytes can't conflict with
	// Go keywords (such as `int` and `var`).
	return "z" + string(bts) + fmt.Sprintf("%d", genSerial())
}

// Use crypto/rand to get an random int64.
func CryptoRandInt64() int64 {
	b := make([]byte, 8)
	_, err := cr.Read(b)
	if err != nil {
		panic(err)
	}
	r := int64(binary.LittleEndian.Uint64(b))
	return r
}

func SeedOurMathRandSrc(seed int64) {
	mathRandSrc.Seed(seed)
}

func MathRandInt64() int64 {
	// generate one rand for the sign, xor with a 2nd.
	return (mathRandSrc.Int63() << 1) ^ mathRandSrc.Int63()
}

const (
	idxChars = "abcdefghijlkmnopqrstuvwxyz"
	idxLen   = 3
)

var nextGenSerial struct {
	mut  sync.Mutex
	next int
}

// genSerial generates serial numbers,
// in sequence, starting at zero. Safe
// for concurrent access.
func genSerial() int {
	nextGenSerial.mut.Lock()
	n := nextGenSerial.next
	nextGenSerial.next++
	nextGenSerial.mut.Unlock()
	return n
}

func cryptoRandIntn(n int) int {
	b := make([]byte, 8)
	_, err := cr.Read(b)
	if err != nil {
		panic(err)
	}
	u := int(binary.LittleEndian.Uint64(b))
	if u < 0 {
		u = -u
	}
	return u % n
}
